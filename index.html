<!DOCTYPE HTML>
<script>

/*
class to parse the .mid file format
(depends on stream.js)
*/
function MidiFile(data) {
	function readChunk(stream) {
		var id = stream.read(4);
		var length = stream.readInt32();
		return {
			'id': id,
			'length': length,
			'data': stream.read(length)
		};
	}
	
	var lastEventTypeByte;
	
	function readEvent(stream) {
		var event = [ stream.readVarInt() ];
		var eventTypeByte = stream.readInt8();
		if ((eventTypeByte & 0xf0) == 0xf0) {
			/* system / meta event */
			if (eventTypeByte == 0xff) {
				/* meta event */
				//event.type = 'meta';
				var subtypeByte = stream.readInt8();
				var length = stream.readVarInt();
		  }
		} else {
			/* channel event */
			var param1;
			if ((eventTypeByte & 0x80) == 0) {
				/* running status - reuse lastEventTypeByte as the event type.
					eventTypeByte is actually the first parameter
				*/
				param1 = eventTypeByte;
				eventTypeByte = lastEventTypeByte;
			} else {
				param1 = stream.readInt8();
				lastEventTypeByte = eventTypeByte;
			}
			var eventType = eventTypeByte >> 4;
			//event.channel = eventTypeByte & 0x0f;
			//event.type = 'channel';
			switch (eventType) {
				case 0x08:
					event.push(0, param1, stream.readInt8() || 0)
					return event;
				case 0x09:
					var t, v = stream.readInt8();
					if (v == 0) {
						t = 0;
					} else {
						t = 1;
					}
					event.push(t, param1, v || 0);
					return event;
				case 0x0a:
					//event.subtype = 'noteAftertouch';
					//event.noteNumber = param1;
					event.amount = stream.readInt8();
					//return event;
				case 0x0b:
					//event.subtype = 'controller';
					//event.controllerType = param1;
					event.value = stream.readInt8();
					//return event;
				case 0x0c:
					//event.subtype = 'programChange';
					//event.programNumber = param1;
					//return event;
				case 0x0d:
					//event.subtype = 'channelAftertouch';
					//event.amount = param1;
					//return event;
				case 0x0e:
					//event.subtype = 'pitchBend';
					event.value = param1 + (stream.readInt8() << 7);
					//return event;
				default:
					//throw "Unrecognised MIDI event type: " + eventType
					/* 
					console.log("Unrecognised MIDI event type: " + eventType);
					stream.readInt8();
					event.subtype = 'unknown';
					*/
					return event;
			}
		}
	}
	
	stream = Stream(data);
	var headerChunk = readChunk(stream);
	var headerStream = Stream(headerChunk.data);
	var formatType = headerStream.readInt16();
	var trackCount = headerStream.readInt16();
	var timeDivision = headerStream.readInt16();
  ticksPerBeat = timeDivision;
	var tracks = [];
	for (var i = 0; i < trackCount; i++) {
		tracks[i] = [];
		var trackChunk = readChunk(stream);
		if (trackChunk.id != 'MTrk') {
			throw "Unexpected chunk - expected MTrk, got "+ trackChunk.id;
		}
		var trackStream = Stream(trackChunk.data);
		while (!trackStream.eof()) {
			var event = readEvent(trackStream);
			if(event)tracks[i].push(event);
			//console.log(event);
		}
	}
	
	return tracks
}


/* Wrapper for accessing strings through sequential reads */
function Stream(str) {
	var position = 0;
	
	function read(length) {
		var result = str.substr(position, length);
		position += length;
		return result;
	}
	
	/* read a big-endian 32-bit integer */
	function readInt32() {
		var result = (
			(str.charCodeAt(position) << 24)
			+ (str.charCodeAt(position + 1) << 16)
			+ (str.charCodeAt(position + 2) << 8)
			+ str.charCodeAt(position + 3));
		position += 4;
		return result;
	}

	/* read a big-endian 16-bit integer */
	function readInt16() {
		var result = (
			(str.charCodeAt(position) << 8)
			+ str.charCodeAt(position + 1));
		position += 2;
		return result;
	}
	
	/* read an 8-bit integer */
	function readInt8(signed) {
		var result = str.charCodeAt(position);
		if (signed && result > 127) result -= 256;
		position += 1;
		return result;
	}
	
	function eof() {
		return position >= str.length;
	}
	
	/* read a MIDI-style variable-length integer
		(big-endian value in groups of 7 bits,
		with top bit set to signify that another byte follows)
	*/
	function readVarInt() {
		var result = 0;
		while (true) {
			var b = readInt8();
			if (b & 0x80) {
				result += (b & 0x7f);
				result <<= 7;
			} else {
				/* b is the last byte */
				return result + b;
			}
		}
	}
	
	return {
		'eof': eof,
		'read': read,
		'readInt32': readInt32,
		'readInt16': readInt16,
		'readInt8': readInt8,
		'readVarInt': readVarInt
	}
}

loadRemote = (path, callback) => {
  var fetch = new XMLHttpRequest();
  fetch.open('GET', path);
  fetch.overrideMimeType("text/plain; charset=x-user-defined");
  fetch.onload = function() {
    var t = this.responseText || "" ;
    var ff = [];
    var mx = t.length;
    var scc= String.fromCharCode;
    for (var z = 0; z < mx; z++) {
      ff[z] = scc(t.charCodeAt(z) & 255);
    }
    callback(ff.join(""));
  }
  fetch.send();
}

play = file => {
  loadRemote(file, data => {
    midiFile = MidiFile(data);
    output.value = JSON.stringify(midiFile,null,0);
  })
}

</script>
<tt>
<h2>MiniMidi</h2>
<br>
- Extracts the tracks from a MIDI file
<p>- "noteOn" and "noteOff" events of each track are saved as [delay, type (0:off/1:on), note, volume]
<p>- Other events are just saved as [delay]
<br>
<br>
<p><input type=file id=f onchange="with(new FileReader)readAsDataURL(files[0]),onload=s=>play(result)"> / Examples: <button onclick="play('1.mid')">1.mid</button> <button onclick="play('2.mid')">2.mid</button> <button onclick="play('3.mid')">3.mid</button>
<br>
<br>
<p><textarea id=output rows=30 cols=80>