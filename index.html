<!DOCTYPE HTML>
<script>

A = new AudioContext,
m = A.createBuffer(1, 1e6, 44100);

// Play a piano note
piano = e => {
  var V, v, p, c, b, w, r, D, i, s, u, D;
  
  for(
  
    // V: note length in seconds
    V = 1,
    
    // Temp vars for guitar synthesis
    v = [],
    p = c = 0,
    
    // Modulation
    // This function generates the i'th sample of a sinusoidal signal with a specific frequency and amplitude
    b = (e, t, a, i) => Math.sin(e / t * 6.28 * a + i),
    
    // Instrument synthesis
    w = (e, t) => Math.sin(e / 44100 * t * 6.28 + b(e, 44100, t, 0) ** 2 + .75 * b(e, 44100, t, .25) + .1 * b(e, 44100, t, .5)),
    
    // Sound samples
    D = [],
    
    // Loop on all the samples
    i = 0;
    i < 44100 * V;
    i++
  ){
  
    // Fill the samples array
    D[i] =
    
      // The first 88 samples represent the note's attack
      i < 88 
      ? i / 88.2 * w(i, e) 
      
      // The other samples represent the rest of the note
      : (1 - (i - 88.2) / (44100 * (V - .002))) ** ((.5 * Math.log(1e4 * e / 44100)) ** 2) * w(i, e);
  }
  
  // Play the note
  
  m.getChannelData(0).set(D),
  s = A.createBufferSource(),
  s.buffer = m,
  s.connect(A.destination),
  s.start()
}

currnote = 0;

play_note = i => {
  piano(440*1.06**(i - 80));
}

play = (i) => {
  delay = 0;
  started = 0;
  for(i = 0; i < midiFile[1].length; i++){
    if(midiFile[1][i][1]) started = 1;
    if(started) delay += midiFile[1][i][0]*2;
    if(midiFile[1][i][1]){
      console.log("play_note("+midiFile[1][i][2]+")",delay);
      setTimeout("play_note("+midiFile[1][i][2]+")",delay);
    }
  }
}


/*
class to parse the .mid file format
(depends on stream.js)
*/
function MidiFile(data) {
	function readChunk(stream) {
		var id = stream.read(4);
		var length = stream.readInt32();
		return {
			'id': id,
			'length': length,
			'data': stream.read(length)
		};
	}
	
	var lastEventTypeByte;
	
	function readEvent(stream) {
		var event = [ stream.readVarInt() ];
		var eventTypeByte = stream.readInt8();
		if ((eventTypeByte & 0xf0) == 0xf0) {
			/* system / meta event */
			if (eventTypeByte == 0xff) {
				/* meta event */
				//event.type = 'meta';
				var subtypeByte = stream.readInt8();
				var length = stream.readVarInt();
		  }
		} else {
			/* channel event */
			var param1;
			if ((eventTypeByte & 0x80) == 0) {
				/* running status - reuse lastEventTypeByte as the event type.
					eventTypeByte is actually the first parameter
				*/
				param1 = eventTypeByte;
				eventTypeByte = lastEventTypeByte;
			} else {
				param1 = stream.readInt8();
				lastEventTypeByte = eventTypeByte;
			}
			var eventType = eventTypeByte >> 4;
			//event.channel = eventTypeByte & 0x0f;
			//event.type = 'channel';
			switch (eventType) {
				case 0x08:
					event.push(0, param1, stream.readInt8() || 0)
					return event;
				case 0x09:
					var t, v = stream.readInt8();
					if (v == 0) {
						t = 0;
					} else {
						t = 1;
					}
					event.push(t, param1, v || 0);
					return event;
				case 0x0a:
					//event.subtype = 'noteAftertouch';
					//event.noteNumber = param1;
					event.amount = stream.readInt8();
					//return event;
				case 0x0b:
					//event.subtype = 'controller';
					//event.controllerType = param1;
					event.value = stream.readInt8();
					//return event;
				case 0x0c:
					//event.subtype = 'programChange';
					//event.programNumber = param1;
					//return event;
				case 0x0d:
					//event.subtype = 'channelAftertouch';
					//event.amount = param1;
					//return event;
				case 0x0e:
					//event.subtype = 'pitchBend';
					event.value = param1 + (stream.readInt8() << 7);
					//return event;
				default:
					//throw "Unrecognised MIDI event type: " + eventType
					/* 
					console.log("Unrecognised MIDI event type: " + eventType);
					stream.readInt8();
					event.subtype = 'unknown';
					*/
					return event;
			}
		}
	}
	
	stream = Stream(data);
	var headerChunk = readChunk(stream);
	var headerStream = Stream(headerChunk.data);
	var formatType = headerStream.readInt16();
	var trackCount = headerStream.readInt16();
	var timeDivision = headerStream.readInt16();
  ticksPerBeat = timeDivision;
	var tracks = [];
	for (var i = 0; i < trackCount; i++) {
		tracks[i] = [];
		var trackChunk = readChunk(stream);
		if (trackChunk.id != 'MTrk') {
			throw "Unexpected chunk - expected MTrk, got "+ trackChunk.id;
		}
		var trackStream = Stream(trackChunk.data);
		while (!trackStream.eof()) {
			var event = readEvent(trackStream);
			if(event)tracks[i].push(event);
			//console.log(event);
		}
	}
	
	return tracks
}


/* Wrapper for accessing strings through sequential reads */
function Stream(str) {
	var position = 0;
	
	function read(length) {
		var result = str.substr(position, length);
		position += length;
		return result;
	}
	
	/* read a big-endian 32-bit integer */
	function readInt32() {
		var result = (
			(str.charCodeAt(position) << 24)
			+ (str.charCodeAt(position + 1) << 16)
			+ (str.charCodeAt(position + 2) << 8)
			+ str.charCodeAt(position + 3));
		position += 4;
		return result;
	}

	/* read a big-endian 16-bit integer */
	function readInt16() {
		var result = (
			(str.charCodeAt(position) << 8)
			+ str.charCodeAt(position + 1));
		position += 2;
		return result;
	}
	
	/* read an 8-bit integer */
	function readInt8(signed) {
		var result = str.charCodeAt(position);
		if (signed && result > 127) result -= 256;
		position += 1;
		return result;
	}
	
	function eof() {
		return position >= str.length;
	}
	
	/* read a MIDI-style variable-length integer
		(big-endian value in groups of 7 bits,
		with top bit set to signify that another byte follows)
	*/
	function readVarInt() {
		var result = 0;
		while (true) {
			var b = readInt8();
			if (b & 0x80) {
				result += (b & 0x7f);
				result <<= 7;
			} else {
				/* b is the last byte */
				return result + b;
			}
		}
	}
	
	return {
		'eof': eof,
		'read': read,
		'readInt32': readInt32,
		'readInt16': readInt16,
		'readInt8': readInt8,
		'readVarInt': readVarInt
	}
}

loadRemote = (path, callback) => {
  var fetch = new XMLHttpRequest();
  fetch.open('GET', path);
  fetch.overrideMimeType("text/plain; charset=x-user-defined");
  fetch.onload = function() {
    var t = this.responseText || "" ;
    var ff = [];
    var mx = t.length;
    var scc= String.fromCharCode;
    for (var z = 0; z < mx; z++) {
      ff[z] = scc(t.charCodeAt(z) & 255);
    }
    callback(ff.join(""));
  }
  fetch.send();
}

music = file => {
  loadRemote(file, data => {
    midiFile = MidiFile(data);
    output.value = JSON.stringify(midiFile,null,2);
  })
}

</script>
<tt>
<h2>MiniMidi</h2>
<br>
- Extracts the tracks from a MIDI file
<p>- "noteOn" and "noteOff" events of each track are saved as [delay, type (0:off/1:on), note, volume]
<p>- Other events are just saved as [delay]
<br>
<br>
<p><input type=file id=f onchange="with(new FileReader)readAsDataURL(files[0]),onload=s=>music(result)"> / Examples: <button onclick="music('1.mid')">1.mid</button> <button onclick="music('2.mid')">2.mid</button> <button onclick="music('3.mid')">3.mid</button>
<br>
<br>
<p><textarea id=output rows=30 cols=80></textarea>
<br>
<br>
<button onclick="play()">Play</button>